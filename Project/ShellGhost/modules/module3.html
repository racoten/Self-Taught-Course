<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Module 3: Vectored Exception Handling Deep Dive - ShellGhost Course</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x1F47B;</text></svg>">
<link rel="stylesheet" href="../../../assets/course.css">
<style>:root{--accent:#64748b;--accent2:#475569;--gradient:linear-gradient(135deg,#64748b,#475569)}</style>
</head>
<body>

<button class="hamburger" aria-label="Toggle navigation">&#9776;</button>

<nav>
<div class="logo">
<h2>ShellGhost Course</h2>
<span>Single-Instruction Evasion</span>
</div>
<a class="home-link" href="../ShellGhost_index.html">&larr; Course Home</a>
<a class="mod-link" href="module1.html"><span>1. Memory Scanner Evasion Goals</span><span class="diff d1">d1</span></a>
<a class="mod-link" href="module2.html"><span>2. Software Breakpoints &amp; INT3</span><span class="diff d1">d1</span></a>
<a class="mod-link active" href="module3.html"><span>3. Vectored Exception Handling</span><span class="diff d1">d1</span></a>
<a class="mod-link" href="module4.html"><span>4. The ShellGhost Concept</span><span class="diff d2">d2</span></a>
<a class="mod-link" href="module5.html"><span>5. SystemFunction032 &amp; Shellcode Mapping</span><span class="diff d2">d2</span></a>
<a class="mod-link" href="module6.html"><span>6. VEH Handler Implementation</span><span class="diff d2">d2</span></a>
<a class="mod-link" href="module7.html"><span>7. Background: Trap Flag &amp; Single-Stepping</span><span class="diff d3">d3</span></a>
<a class="mod-link" href="module8.html"><span>8. Full Chain &amp; Detection</span><span class="diff d3">d3</span></a>
</nav>

<main>
<span class="diff-badge easy">Difficulty: Beginner</span>
<h1>Module 3: Vectored Exception Handling Deep Dive</h1>
<p class="subtitle">The process-wide exception handler that intercepts every breakpoint before anyone else sees it.</p>

<div class="card highlight">
<h4>Module Objective</h4>
<p>This module provides a deep understanding of Windows Vectored Exception Handling (VEH): how handlers are registered with <code>AddVectoredExceptionHandler</code>, the priority system that ensures ShellGhost's handler runs first, the <code>EXCEPTION_POINTERS</code> structure that provides access to exception details and thread context, and how the handler manipulates the <code>CONTEXT</code> structure to control execution flow. VEH is the interception mechanism that gives ShellGhost control over every INT3 exception.</p>
</div>

<!-- ============================================================ -->
<h2>1. VEH vs SEH: Why VEH?</h2>

<p>Windows provides two exception handling mechanisms that user-mode code can use. Understanding the difference is critical to understanding why ShellGhost uses VEH.</p>

<table>
<tr><th>Feature</th><th>Structured Exception Handling (SEH)</th><th>Vectored Exception Handling (VEH)</th></tr>
<tr><td><strong>Scope</strong></td><td>Per-function / per-thread (frame-based)</td><td>Process-wide (global)</td></tr>
<tr><td><strong>Priority</strong></td><td>Called <strong>after</strong> VEH handlers</td><td>Called <strong>before</strong> SEH handlers</td></tr>
<tr><td><strong>Registration</strong></td><td>Compiler-generated (<code>__try/__except</code>)</td><td>Runtime API (<code>AddVectoredExceptionHandler</code>)</td></tr>
<tr><td><strong>Stack-based?</strong></td><td>Yes &mdash; tied to stack frames</td><td>No &mdash; stored in a global linked list</td></tr>
<tr><td><strong>Thread scope</strong></td><td>Per-thread handler chain</td><td>All threads share the same handlers</td></tr>
<tr><td><strong>Can modify CONTEXT?</strong></td><td>Yes (via <code>GetExceptionInformation()</code>)</td><td>Yes (via <code>EXCEPTION_POINTERS</code>)</td></tr>
</table>

<div class="card green">
<h4>VEH Advantage for ShellGhost</h4>
<p>VEH handlers are called <strong>before</strong> the SEH chain is walked. This means ShellGhost's VEH handler gets first crack at every exception in the process, regardless of which thread generates it and regardless of any <code>__try/__except</code> blocks in the call stack. Since ShellGhost needs to intercept every single INT3 exception generated by the 0xCC-filled execution buffer, VEH's process-wide, first-priority nature is exactly what is needed.</p>
</div>

<!-- ============================================================ -->
<h2>2. The Exception Dispatch Order</h2>

<p>When an exception occurs, Windows dispatches it through a defined sequence. Understanding this order explains why VEH guarantees ShellGhost's handler runs first:</p>

<div class="diagram">
<h4 style="color:var(--accent);margin-bottom:15px;text-align:center">User-Mode Exception Dispatch Order</h4>
<div class="flow">
<div class="flow box">1. VEH Handlers<br><small>Global, first priority</small></div>
<div class="flow arrow">&rarr;</div>
<div class="flow box">2. SEH Chain<br><small>Per-frame, stack walk</small></div>
<div class="flow arrow">&rarr;</div>
<div class="flow box">3. VCH Handlers<br><small>Vectored Continue</small></div>
<div class="flow arrow">&rarr;</div>
<div class="flow box">4. Unhandled Filter<br><small>Last chance</small></div>
<div class="flow arrow">&rarr;</div>
<div class="flow box">5. Process Crash<br><small>Termination</small></div>
</div>
</div>

<ol>
<li><strong>Vectored Exception Handlers (VEH)</strong>: Called first. If any handler returns <code>EXCEPTION_CONTINUE_EXECUTION</code>, dispatch stops and execution resumes with the (potentially modified) context.</li>
<li><strong>Structured Exception Handlers (SEH)</strong>: Only reached if no VEH handler handled the exception. Walks the per-thread stack-based handler chain.</li>
<li><strong>Vectored Continue Handlers (VCH)</strong>: Called after an SEH handler returns <code>EXCEPTION_CONTINUE_EXECUTION</code>. Rarely used.</li>
<li><strong>Unhandled Exception Filter</strong>: The last-resort handler registered via <code>SetUnhandledExceptionFilter</code>.</li>
<li><strong>Process Termination</strong>: If nothing handles the exception, the process crashes.</li>
</ol>

<!-- ============================================================ -->
<h2>3. Registering a VEH Handler</h2>

<p>The <code>AddVectoredExceptionHandler</code> API registers a new VEH handler. Its <code>First</code> parameter controls whether the handler is inserted at the beginning or end of the VEH list:</p>

<pre><span class="lang-tag">C</span>// Function signature (from winnt.h / errhandlingapi.h)
PVOID AddVectoredExceptionHandler(
    ULONG First,                          // 1 = first in list, 0 = last
    PVECTORED_EXCEPTION_HANDLER Handler   // pointer to handler function
);

// Handler function signature
LONG CALLBACK VectoredHandler(
    PEXCEPTION_POINTERS ExceptionInfo     // exception + context
);

// Return values from the handler:
#define EXCEPTION_CONTINUE_EXECUTION  (-1)  // resume execution
#define EXCEPTION_CONTINUE_SEARCH      (0)  // pass to next handler</pre>

<div class="card">
<h4>The First Parameter</h4>
<p>When <code>First = 1</code>, the handler is inserted at the <strong>head</strong> of the VEH linked list, meaning it will be the first handler called for any exception. ShellGhost registers its handler with <code>First = 1</code> to ensure it processes breakpoint exceptions before any other VEH handler in the process. If multiple handlers are registered with <code>First = 1</code>, the most recently registered one is called first (LIFO order).</p>
</div>

<pre><span class="lang-tag">C</span>// ShellGhost's VEH registration
PVOID hVeh = AddVectoredExceptionHandler(
    1,              // First = 1: highest priority
    ShellGhostHandler
);

if (hVeh == NULL) {
    // Registration failed
    return -1;
}

// Later, when done:
RemoveVectoredExceptionHandler(hVeh);</pre>

<!-- ============================================================ -->
<h2>4. The EXCEPTION_POINTERS Structure</h2>

<p>The VEH handler receives a single argument: a pointer to an <code>EXCEPTION_POINTERS</code> structure. This structure contains everything the handler needs to understand the exception and modify the execution state:</p>

<pre><span class="lang-tag">C</span>typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;  // What happened
    PCONTEXT          ContextRecord;    // CPU state when it happened
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;</pre>

<div class="card">
<h4>ExceptionRecord Fields</h4>
<pre><span class="lang-tag">C</span>typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;          // e.g., 0x80000003 (BREAKPOINT)
    DWORD ExceptionFlags;         // 0 = first-chance, 1 = non-continuable
    struct _EXCEPTION_RECORD *ExceptionRecord;  // nested exception
    PVOID ExceptionAddress;       // instruction that caused the exception
    DWORD NumberParameters;       // number of params in array below
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;</pre>
<p>For ShellGhost, the two critical fields are <code>ExceptionCode</code> (to identify breakpoint exceptions) and <code>ExceptionAddress</code> (to know which instruction in the execution buffer triggered the exception).</p>
</div>

<!-- ============================================================ -->
<h2>5. The CONTEXT Structure</h2>

<p>The <code>CONTEXT</code> structure represents the complete CPU register state at the moment of the exception. This is the mechanism that allows the VEH handler to <strong>change execution flow</strong>:</p>

<pre><span class="lang-tag">C</span>// Key fields of the x64 CONTEXT structure (simplified)
typedef struct _CONTEXT {
    // Control registers
    DWORD64 Rip;        // Instruction pointer - where to resume
    DWORD64 Rsp;        // Stack pointer
    DWORD   EFlags;     // Flags register (includes Trap Flag at bit 8)
    WORD    SegCs;      // Code segment

    // General-purpose registers
    DWORD64 Rax, Rcx, Rdx, Rbx;
    DWORD64 Rbp, Rsi, Rdi;
    DWORD64 R8, R9, R10, R11, R12, R13, R14, R15;

    // ... SSE registers, debug registers, etc.
} CONTEXT;</pre>

<div class="card green">
<h4>CONTEXT Manipulation in ShellGhost</h4>
<p>The VEH handler uses the CONTEXT before returning <code>EXCEPTION_CONTINUE_EXECUTION</code>:</p>
<ul>
<li><strong>Rip</strong>: Used directly to identify the current instruction position. The Windows kernel (<code>KiDispatchException</code>) already decrements RIP by 1 for EXCEPTION_BREAKPOINT, so <code>ContextRecord-&gt;Rip</code> points to the <code>0xCC</code> byte. No manual adjustment needed.</li>
<li><strong>Memory protection</strong>: The handler toggles the page between RW (for writing decrypted bytes) and RX (for execution) using <code>VirtualProtect</code></li>
<li><strong>Any register the shellcode modifies</strong>: The handler does not touch these &mdash; they are preserved naturally by the CONTEXT save/restore</li>
</ul>
<p>When the handler returns <code>EXCEPTION_CONTINUE_EXECUTION</code>, the kernel restores the CONTEXT to the CPU, and execution resumes at Rip where the decrypted instruction now resides.</p>
</div>

<!-- ============================================================ -->
<h2>6. Handler Return Values</h2>

<p>A VEH handler must return one of two values:</p>

<table>
<tr><th>Return Value</th><th>Constant</th><th>Effect</th></tr>
<tr><td><code>-1</code></td><td><code>EXCEPTION_CONTINUE_EXECUTION</code></td><td>Stop dispatch. Restore the (potentially modified) CONTEXT and resume execution. This is what ShellGhost returns for handled breakpoint exceptions.</td></tr>
<tr><td><code>0</code></td><td><code>EXCEPTION_CONTINUE_SEARCH</code></td><td>Continue dispatch. Pass the exception to the next handler in the VEH list, then to SEH. ShellGhost returns this for exceptions it does not handle (e.g., access violations from the shellcode itself).</td></tr>
</table>

<pre><span class="lang-tag">C</span>// ShellGhost's handler logic (simplified)
LONG CALLBACK ShellGhostHandler(PEXCEPTION_POINTERS ep) {
    DWORD code = ep->ExceptionRecord->ExceptionCode;

    if (code == EXCEPTION_BREAKPOINT) {
        // Re-encrypt previous instruction (if any),
        // decrypt current instruction, toggle RW/RX
        // ... (covered in Module 6)
        return EXCEPTION_CONTINUE_EXECUTION;
    }

    // Not our exception - let someone else handle it
    return EXCEPTION_CONTINUE_SEARCH;
}</pre>

<!-- ============================================================ -->
<h2>7. VEH Internals: The Handler List</h2>

<p>Internally, Windows maintains VEH handlers in a doubly-linked list protected by a critical section. Understanding this structure helps explain registration and removal behavior:</p>

<pre><span class="lang-tag">C</span>// Internal structure (ntdll, not officially documented)
typedef struct _VECTORED_HANDLER_ENTRY {
    LIST_ENTRY                    List;       // Doubly-linked list pointers
    ULONG                         Refs;       // Reference count
    PVECTORED_EXCEPTION_HANDLER   Handler;    // The handler function pointer
    // Note: In modern Windows, the handler pointer is
    // encoded with RtlEncodePointer for security
} VECTORED_HANDLER_ENTRY;

// The global list head lives in ntdll:
// ntdll!LdrpVectorHandlerList (exception handlers)
// ntdll!LdrpVectorHandlerList + sizeof(LIST_ENTRY) (continue handlers)</pre>

<div class="card">
<h4>Pointer Encoding</h4>
<p>Since Windows Vista, the handler function pointers stored in the VEH list are encoded using <code>RtlEncodePointer</code> (which XORs the pointer with a per-process secret cookie). This prevents an attacker from overwriting a VEH handler pointer in memory to redirect execution. The encoding is transparent to normal API usage &mdash; <code>AddVectoredExceptionHandler</code> encodes, and the dispatch code decodes before calling.</p>
</div>

<!-- ============================================================ -->
<h2>8. VEH in the ShellGhost Architecture</h2>

<p>Here is how VEH fits into the overall ShellGhost execution model:</p>

<div class="diagram">
<h4 style="color:var(--accent);margin-bottom:15px;text-align:center">VEH's Role in the Execution Cycle</h4>
<div class="flow">
<div class="flow box">CPU hits 0xCC<br><small>EXCEPTION_BREAKPOINT</small></div>
<div class="flow arrow">&rarr;</div>
<div class="flow box">VEH Handler Called<br><small>First priority</small></div>
<div class="flow arrow">&rarr;</div>
<div class="flow box">Re-encrypt prev, Decrypt curr<br><small>Toggle RW&harr;RX</small></div>
<div class="flow arrow">&rarr;</div>
<div class="flow box">CONTINUE_EXECUTION<br><small>Resume at Rip</small></div>
</div>
</div>

<pre><span class="lang-tag">C</span>// Complete VEH setup for ShellGhost (simplified)
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

// Forward declaration of the handler
LONG CALLBACK GhostHandler(PEXCEPTION_POINTERS ep);

int main() {
    // Step 1: Prepare the per-instruction encrypted shellcode data
    // (generated by ShellGhost_mapping.py preprocessing script)
    unsigned char encrypted_sc[] = { /* per-instruction encrypted data */ };
    SIZE_T sc_size = sizeof(encrypted_sc);

    // Step 2: Allocate execution buffer filled with 0xCC (RW, not RWX)
    LPVOID exec_buf = VirtualAlloc(NULL, sc_size,
        MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    memset(exec_buf, 0xCC, sc_size);

    // Step 3: Register VEH handler with highest priority
    PVOID hVeh = AddVectoredExceptionHandler(1, GhostHandler);

    // Step 4: Create a thread whose entry point is at the end of .text
    // ResolveEndofTextSegment() finds null bytes in .text to use as entry
    // The first 0xCC triggers EXCEPTION_BREAKPOINT
    LPVOID entry = ResolveEndofTextSegment();
    HANDLE hThread = CreateThread(NULL, 0,
        (LPTHREAD_START_ROUTINE)entry, NULL, 0, NULL);
    WaitForSingleObject(hThread, INFINITE);

    // Step 5: Cleanup (if shellcode returns)
    RemoveVectoredExceptionHandler(hVeh);
    VirtualFree(exec_buf, 0, MEM_RELEASE);
    return 0;
}</pre>

<div class="card warn">
<h4>Thread Safety Consideration</h4>
<p>Because VEH is process-wide, the handler will be invoked for exceptions on <strong>any thread</strong>, not just the thread executing shellcode. ShellGhost's handler must verify that the exception address falls within the execution buffer before processing it. Exceptions from other threads (or from addresses outside the buffer) should be passed through by returning <code>EXCEPTION_CONTINUE_SEARCH</code>.</p>
</div>

<!-- ============================================================ -->
<div class="quiz">
<h2>Knowledge Check</h2>

<div class="quiz-q" data-answer="B">
<p>Q1: In the Windows exception dispatch order, when are VEH handlers called relative to SEH handlers?</p>
<div class="quiz-btn" data-choice="A">A) After SEH handlers</div>
<div class="quiz-btn" data-choice="B">B) Before SEH handlers</div>
<div class="quiz-btn" data-choice="C">C) At the same time as SEH handlers</div>
<div class="quiz-btn" data-choice="D">D) Only if SEH handlers fail</div>
</div>

<div class="quiz-q" data-answer="C">
<p>Q2: What does AddVectoredExceptionHandler return when registration succeeds?</p>
<div class="quiz-btn" data-choice="A">A) TRUE (1)</div>
<div class="quiz-btn" data-choice="B">B) The exception code</div>
<div class="quiz-btn" data-choice="C">C) A handle to the registered handler (PVOID)</div>
<div class="quiz-btn" data-choice="D">D) The handler's position in the list</div>
</div>

<div class="quiz-q" data-answer="A">
<p>Q3: What must the VEH handler return to resume execution with the modified CONTEXT?</p>
<div class="quiz-btn" data-choice="A">A) EXCEPTION_CONTINUE_EXECUTION (-1)</div>
<div class="quiz-btn" data-choice="B">B) EXCEPTION_CONTINUE_SEARCH (0)</div>
<div class="quiz-btn" data-choice="C">C) TRUE (1)</div>
<div class="quiz-btn" data-choice="D">D) STATUS_SUCCESS (0)</div>
</div>
</div>

<div class="nav-btns">
<a href="module2.html">&larr; Prev: Software Breakpoints &amp; INT3</a>
<a class="primary" href="module4.html">Next: The ShellGhost Concept &rarr;</a>
</div>
</main>

<script src="../../../assets/course.js"></script>
</body>
</html>
